<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>멀티 이미지 HSV (JS vs WASM 동시 표시, 직렬 이미지 처리)</title>
  <style>
    body { font-family: system-ui, sans-serif; text-align: center; margin: 20px; }
    h2 { margin-bottom: 10px; }
    .controls { display:flex; flex-direction:column; align-items:center; gap:10px; margin-bottom: 18px; }
    label { display:flex; align-items:center; gap:10px; min-width: 340px; }
    input[type="range"] { width: 240px; }
    #gallery { display:flex; flex-direction:column; gap:28px; align-items:center; }
    .pair { display:flex; gap:28px; flex-wrap:wrap; justify-content:center; }
    .block { display:flex; flex-direction:column; align-items:center; }
    canvas { border:1px solid #0003; margin-top:6px; max-width:420px; height:auto; }
    .perf { font-size: 13px; color:#555; margin-top:6px; }
    .summary { margin-top: 22px; font-weight:600; }
    .muted { opacity: .6; }
  </style>
</head>
<body>
  <h2>여러 이미지 HSV (JS vs WASM 동시, 이미지 직렬)</h2>

  <div class="controls">
    <input type="file" id="imgInput" accept="image/*" multiple />
    <label>Hue:
      <input type="range" id="hue" min="0" max="360" value="0" />
      <span id="hueVal">0°</span>
    </label>
    <label>Saturation:
      <input type="range" id="sat" min="0" max="200" value="100" />
      <span id="satVal">100%</span>
    </label>
    <label>Value:
      <input type="range" id="val" min="0" max="200" value="100" />
      <span id="valVal">100%</span>
    </label>
  </div>

  <div id="gallery"></div>
  <div id="summary" class="summary muted">이미지를 업로드하세요.</div>

  <script>
    // Emscripten 모듈: 전역 Module로 로딩
    var Module = {
      onRuntimeInitialized() {
        console.log("✅ WASM Runtime Initialized");
        setupWASM();
      }
    };
  </script>
  <script>document.write(`<script src="hsv.js?v=${Date.now()}"><\/script>`);</script>

  <script>
    const imgInput = document.getElementById("imgInput");
    const hue = document.getElementById("hue");
    const sat = document.getElementById("sat");
    const val = document.getElementById("val");
    const hueVal = document.getElementById("hueVal");
    const satVal = document.getElementById("satVal");
    const valVal = document.getElementById("valVal");
    const gallery = document.getElementById("gallery");
    const summary = document.getElementById("summary");

    let adjust_hsv = null;
    let wasmReady = false;

    // 업로드된 각 이미지의 원본과 캔버스/컨텍스트 보관
    // items[]: { original, js:{canvas,ctx,perf}, wasm:{canvas,ctx,perf} }
    const items = [];

    function setupWASM() {
      // C 함수 바인딩
      adjust_hsv = Module.cwrap("adjust_hsv", "void", ["number","number","number","number","number"]);
      wasmReady = true;
      if (items.length === 0) {
        summary.textContent = "WASM 준비 완료. 이미지를 업로드하세요.";
        summary.classList.remove("muted");
      }
    }

    imgInput.addEventListener("change", (e) => {
      gallery.innerHTML = "";
      items.length = 0;
      summary.textContent = "이미지 로딩 중...";
      summary.classList.add("muted");

      const files = [...e.target.files];
      if (!files.length) {
        summary.textContent = "이미지를 업로드하세요.";
        return;
      }

      let loaded = 0;
      files.forEach((file) => {
        const img = new Image();
        img.onload = () => {
          // 행(페어) 생성: JS / WASM 블럭
          const row = document.createElement("div");
          row.className = "pair";

          const jsBlock = createBlock("JS 결과", file.name);
          const wasmBlock = createBlock("WASM 결과", file.name);
          row.append(jsBlock.container, wasmBlock.container);
          gallery.appendChild(row);

          // 두 캔버스를 동일 원본 크기로 설정
          jsBlock.canvas.width = wasmBlock.canvas.width = img.width;
          jsBlock.canvas.height = wasmBlock.canvas.height = img.height;

          // 원본을 JS 쪽에 그려서 ImageData 획득
          jsBlock.ctx.drawImage(img, 0, 0);
          wasmBlock.ctx.drawImage(img, 0, 0);
          const original = jsBlock.ctx.getImageData(0, 0, img.width, img.height);

          items.push({ original, js: jsBlock, wasm: wasmBlock });

          loaded++;
          if (loaded === files.length) {
            summary.textContent = `총 ${items.length}장 로드됨. 슬라이더로 조정하세요.`;
            summary.classList.remove("muted");
          }
        };
        img.src = URL.createObjectURL(file);
      });
    });

    function createBlock(label, name) {
      const container = document.createElement("div");
      container.className = "block";
      const title = document.createElement("h4");
      title.textContent = `${label} (${name})`;
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const perf = document.createElement("div");
      perf.className = "perf";
      perf.textContent = `${label} 처리시간: -`;
      container.append(title, canvas, perf);
      return { container, canvas, ctx, perf };
    }

    // 슬라이더 변경 → 이미지별로 "직렬" 처리
    [hue, sat, val].forEach(sl => sl.addEventListener("input", runSerial));

    async function runSerial() {
      if (!items.length) return;

      hueVal.textContent = `${hue.value}°`;
      satVal.textContent = `${sat.value}%`;
      valVal.textContent = `${val.value}%`;

      summary.textContent = "⏳ 직렬 처리 중…";
      summary.classList.add("muted");

      let totalJS = 0;
      let totalWASM = 0;

      // 이미지별로 순차(직렬) 처리
      for (const it of items) {
        // 같은 이미지에 대해 JS & WASM 병렬 실행
        const [tJS, tWASM] = await Promise.all([
          new Promise(res => setTimeout(() => res(processJS(it)), 0)),
          new Promise(res => setTimeout(() => res(processWASM(it)), 0)),
        ]);
        totalJS += tJS;
        totalWASM += tWASM;
      }

      const avgJS = (totalJS / items.length).toFixed(2);
      const avgWASM = (totalWASM / items.length).toFixed(2);

      summary.textContent =
        `✅ JS 총합: ${totalJS.toFixed(2)} ms (평균 ${avgJS} ms) ｜ ` +
        `✅ WASM 총합: ${totalWASM.toFixed(2)} ms (평균 ${avgWASM} ms)`;
      summary.classList.remove("muted");
    }

    // JS 처리 (순수 JS, 각 이미지당 시간 반환)
    function processJS(it) {
      const { original, js } = it;
      const { ctx, perf } = js;

      const hueShift = +hue.value / 360;
      const satScale = +sat.value / 100;
      const valScale = +val.value / 100;

      const data = new Uint8ClampedArray(original.data);
      const t0 = performance.now();

      for (let i = 0; i < data.length; i += 4) {
        let r = data[i] / 255, g = data[i+1] / 255, b = data[i+2] / 255;
        const max = Math.max(r,g,b), min = Math.min(r,g,b), d = max - min;
        let h = 0, s = 0, v = max;
        if (d !== 0) {
          s = d / max;
          switch (max) {
            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
            case g: h = ((b - r) / d + 2) / 6; break;
            case b: h = ((r - g) / d + 4) / 6; break;
          }
        }
        h = (h + hueShift) % 1;
        s = Math.min(s * satScale, 1);
        v = Math.min(v * valScale, 1);

        const c = v * s;
        const x = c * (1 - Math.abs(((h * 6) % 2) - 1));
        const m = v - c;
        let r1=0,g1=0,b1=0;
        if (h < 1/6) [r1,g1,b1] = [c,x,0];
        else if (h < 2/6) [r1,g1,b1] = [x,c,0];
        else if (h < 3/6) [r1,g1,b1] = [0,c,x];
        else if (h < 4/6) [r1,g1,b1] = [0,x,c];
        else if (h < 5/6) [r1,g1,b1] = [x,0,c];
        else [r1,g1,b1] = [c,0,x];

        data[i]   = (r1 + m) * 255;
        data[i+1] = (g1 + m) * 255;
        data[i+2] = (b1 + m) * 255;
      }

      const t1 = performance.now();
      ctx.putImageData(new ImageData(data, original.width, original.height), 0, 0);
      const dt = t1 - t0;
      perf.textContent = `JS 처리시간: ${dt.toFixed(2)} ms`;
      return dt;
    }

    // WASM 처리 (같은 이미지에 대해 JS와 병렬로 실행)
    function processWASM(it) {
      if (!wasmReady) return 0;
      const { original, wasm } = it;
      const { ctx, perf } = wasm;

      const hueShift = +hue.value / 360;
      const satScale = +sat.value / 100;
      const valScale = +val.value / 100;
      const len = original.data.length;

      const t0 = performance.now();

      // 1) 원본 -> HEAPU8 (복사 1회)
      const ptr = Module._malloc(len);
      const heap = new Uint8Array(HEAPU8.buffer, ptr, len);
      heap.set(original.data);

      // 2) 네이티브 계산
      adjust_hsv(ptr, len, hueShift, satScale, valScale);

      // 3) HEAPU8 -> JS (복사 1회)
      const out = new Uint8ClampedArray(len);
      out.set(heap);

      Module._free(ptr);

      const t1 = performance.now();
      ctx.putImageData(new ImageData(out, original.width, original.height), 0, 0);
      const dt = t1 - t0;
      perf.textContent = `WASM 처리시간: ${dt.toFixed(2)} ms`;
      return dt;
    }
  </script>
</body>
</html>
