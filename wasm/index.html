<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>WASM vs JavaScript HSV ÎπÑÍµê</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: sans-serif;
        padding: 20px;
      }
      .container {
        display: flex;
        gap: 30px;
        margin-top: 20px;
      }
      .canvas-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      canvas {
        border: 2px solid #333;
        max-width: 600px;
        max-height: 450px;
        object-fit: contain;
      }
      .controls {
        margin: 20px 0;
        text-align: center;
      }
      input[type="range"] {
        margin: 5px;
        width: 300px;
      }
      .performance {
        margin-top: 10px;
        font-weight: bold;
        padding: 10px;
        border-radius: 5px;
      }
      .wasm-perf {
        color: #0066cc;
        background: #e6f2ff;
      }
      .js-perf {
        color: #cc6600;
        background: #fff2e6;
      }
      h3 {
        margin: 10px 0;
      }
      .winner {
        font-size: 24px;
        margin-top: 20px;
        padding: 15px;
        background: #f0f0f0;
        border-radius: 8px;
      }
      .processing {
        background: #fff9e6;
        color: #cc9900;
      }
    </style>
  </head>
  <body>
    <h1>üèéÔ∏è WASM vs JavaScript HSV ÏÑ±Îä• ÎπÑÍµê</h1>

    <div class="winner" id="winner" style="margin-bottom: 10px;">Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî</div>

    <div style="display: flex; gap: 30px; margin-bottom: 20px;">
      <div class="performance wasm-perf">üöÄ WASM: <span id="timeWasm">-</span></div>
      <div class="performance js-perf">üìú JavaScript: <span id="timeJs">-</span></div>
    </div>

    <div class="performance" style="margin-bottom: 20px;">WASM ÏÉÅÌÉú: <span id="wasmStatus">Î°úÎî© Ï§ë...</span></div>

    <div class="controls">
      <input type="file" id="imgInput" accept="image/*" />
      <br><br>
      <label>
        Hue: <input type="range" id="hue" min="0" max="360" value="0" />
        <span id="hueValue">0</span>
      </label>
      <br>
      <label>
        Saturation: <input type="range" id="sat" min="0" max="200" value="100" />
        <span id="satValue">100</span>
      </label>
      <br>
      <label>
        Value: <input type="range" id="val" min="0" max="200" value="100" />
        <span id="valValue">100</span>
      </label>
    </div>

    <div class="container">
      <div class="canvas-wrapper">
        <h3>üöÄ WASM</h3>
        <canvas id="canvasWasm"></canvas>
      </div>
      <div class="canvas-wrapper">
        <h3>üìú JavaScript</h3>
        <canvas id="canvasJs"></canvas>
      </div>
    </div>

    <script type="module">
      import createModule from './hsv.js';

      const canvasWasm = document.getElementById('canvasWasm');
      const canvasJs = document.getElementById('canvasJs');
      const ctxWasm = canvasWasm.getContext('2d');
      const ctxJs = canvasJs.getContext('2d');
      let originalData = null;
      let wasmModule = null;

      const imgInput = document.getElementById('imgInput');
      const hueSlider = document.getElementById('hue');
      const satSlider = document.getElementById('sat');
      const valSlider = document.getElementById('val');
      const timeWasmDisplay = document.getElementById('timeWasm');
      const timeJsDisplay = document.getElementById('timeJs');
      const winnerDisplay = document.getElementById('winner');
      const wasmStatus = document.getElementById('wasmStatus');

      // ===== JavaScript HSV Ìï®ÏàòÎì§ =====
      function rgbToHsv(r, g, b) {
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const d = max - min;

        let h = 0;
        const s = max === 0 ? 0 : d / max;
        const v = max;

        if (d !== 0) {
          if (max === r) {
            h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
          } else if (max === g) {
            h = ((b - r) / d + 2) / 6;
          } else {
            h = ((r - g) / d + 4) / 6;
          }
        }

        return { h, s, v };
      }

      function hsvToRgb(h, s, v) {
        const c = v * s;
        const x = c * (1 - Math.abs((h * 6) % 2 - 1));
        const m = v - c;

        let r1 = 0, g1 = 0, b1 = 0;

        if (h < 1/6) {
          r1 = c; g1 = x; b1 = 0;
        } else if (h < 2/6) {
          r1 = x; g1 = c; b1 = 0;
        } else if (h < 3/6) {
          r1 = 0; g1 = c; b1 = x;
        } else if (h < 4/6) {
          r1 = 0; g1 = x; b1 = c;
        } else if (h < 5/6) {
          r1 = x; g1 = 0; b1 = c;
        } else {
          r1 = c; g1 = 0; b1 = x;
        }

        return {
          r: r1 + m,
          g: g1 + m,
          b: b1 + m
        };
      }

      function applyHsvJs(data, hueShift, satScale, valScale) {
        for (let i = 0; i < data.length; i += 4) {
          // RGB Ï†ïÍ∑úÌôî (0-1)
          const r = data[i] / 255;
          const g = data[i + 1] / 255;
          const b = data[i + 2] / 255;

          // RGB ‚Üí HSV
          let { h, s, v } = rgbToHsv(r, g, b);

          // HSV Ï°∞Ï†ï
          h = (h + hueShift) % 1;
          s = Math.min(s * satScale, 1);
          v = Math.min(v * valScale, 1);

          // HSV ‚Üí RGB
          const rgb = hsvToRgb(h, s, v);

          // 0-255 Î≤îÏúÑÎ°ú Î≥ÄÌôò
          data[i] = Math.round(rgb.r * 255);
          data[i + 1] = Math.round(rgb.g * 255);
          data[i + 2] = Math.round(rgb.b * 255);
        }
      }

      // WASM Î™®Îìà Î°úÎìú
      createModule().then((module) => {
        wasmModule = module;
        wasmStatus.textContent = 'Î°úÎìú ÏôÑÎ£å ‚úì';
        wasmStatus.style.color = 'green';
        console.log('WASM Î™®Îìà Î°úÎìú ÏôÑÎ£å', module);
      }).catch((err) => {
        wasmStatus.textContent = 'Î°úÎìú Ïã§Ìå® ‚úó';
        wasmStatus.style.color = 'red';
        console.error('WASM Î°úÎìú ÏóêÎü¨:', err);
      });

      // Ïä¨ÎùºÏù¥Îçî Í∞í ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
      hueSlider.addEventListener('input', (e) => {
        document.getElementById('hueValue').textContent = e.target.value;
      });
      satSlider.addEventListener('input', (e) => {
        document.getElementById('satValue').textContent = e.target.value;
      });
      valSlider.addEventListener('input', (e) => {
        document.getElementById('valValue').textContent = e.target.value;
      });

      // Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
      imgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const img = new Image();
        img.onload = () => {
          // ÏõêÎ≥∏ ÏÇ¨Ïù¥Ï¶à Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
          canvasWasm.width = img.width;
          canvasWasm.height = img.height;
          canvasJs.width = img.width;
          canvasJs.height = img.height;

          ctxWasm.drawImage(img, 0, 0);
          originalData = ctxWasm.getImageData(0, 0, canvasWasm.width, canvasWasm.height);
          updateImage();
        };
        img.src = URL.createObjectURL(file);
      });

      // Ïä¨ÎùºÏù¥Îçî Î≥ÄÍ≤Ω Ïãú Ïù¥ÎØ∏ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ (throttle Ï†ÅÏö©)
      let updateScheduled = false;
      let isProcessing = false;

      function scheduleUpdate() {
        if (!updateScheduled) {
          updateScheduled = true;
          requestAnimationFrame(() => {
            updateImage();
            updateScheduled = false;
          });
        }
      }

      [hueSlider, satSlider, valSlider].forEach((slider) => {
        slider.addEventListener('input', scheduleUpdate);
      });

      function updateImage() {
        if (!originalData) {
          console.log('Ïù¥ÎØ∏ÏßÄÎ•º Î®ºÏ†Ä ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî');
          return;
        }

        // Ïù¥ÎØ∏ Ï≤òÎ¶¨ Ï§ëÏù¥Î©¥ Ïä§ÌÇµ
        if (isProcessing) {
          console.log('Ïù¥ÎØ∏ Ï≤òÎ¶¨ Ï§ë...');
          return;
        }

        isProcessing = true;
        winnerDisplay.textContent = '‚è≥ Ï≤òÎ¶¨ Ï§ë...';
        winnerDisplay.className = 'winner processing';

        // HSV ÌååÎùºÎØ∏ÌÑ∞
        const hueShift = parseFloat(hueSlider.value) / 360;
        const satScale = parseFloat(satSlider.value) / 100;
        const valScale = parseFloat(valSlider.value) / 100;

        let wasmTime = 0;
        let jsTime = 0;

        // Ï≤òÎ¶¨ ÏãúÏûë ÏãúÍ∞Å ÌëúÏãú
        timeWasmDisplay.textContent = 'Ï≤òÎ¶¨ Ï§ë...';
        timeJsDisplay.textContent = 'Ï≤òÎ¶¨ Ï§ë...';

        let wasmDone = false;
        let jsDone = false;

        function checkBothDone() {
          if (wasmDone && jsDone) {
            // ===== ÏäπÏûê ÌëúÏãú =====
            winnerDisplay.className = 'winner';
            if (wasmModule && wasmTime > 0 && jsTime > 0) {
              const speedup = (jsTime / wasmTime).toFixed(2);
              if (wasmTime < jsTime) {
                winnerDisplay.textContent = `üèÜ WASM ÏäπÎ¶¨! ${speedup}Î∞∞ Îπ†Î¶Ñ`;
                winnerDisplay.style.color = '#0066cc';
              } else {
                winnerDisplay.textContent = `üèÜ JavaScript ÏäπÎ¶¨! ${(wasmTime / jsTime).toFixed(2)}Î∞∞ Îπ†Î¶Ñ`;
                winnerDisplay.style.color = '#cc6600';
              }
            }
            isProcessing = false;
          }
        }

        // ===== WASM Î≤ÑÏ†Ñ (ÎπÑÎèôÍ∏∞) =====
        if (wasmModule) {
          setTimeout(() => {
            const startWasm = performance.now();

            const dataWasm = new Uint8ClampedArray(originalData.data);
            const dataLength = dataWasm.length;
            const dataPtr = wasmModule._malloc(dataLength);

            const heap = new Uint8Array(wasmModule.HEAPU8.buffer, dataPtr, dataLength);
            heap.set(dataWasm);

            wasmModule.applyHsvAdjustment(dataPtr, dataLength, hueShift, satScale, valScale);

            dataWasm.set(new Uint8Array(wasmModule.HEAPU8.buffer, dataPtr, dataLength));
            wasmModule._free(dataPtr);

            const imageDataWasm = new ImageData(dataWasm, originalData.width, originalData.height);
            ctxWasm.putImageData(imageDataWasm, 0, 0);

            wasmTime = performance.now() - startWasm;
            timeWasmDisplay.textContent = `${wasmTime.toFixed(2)}ms ‚úì`;

            wasmDone = true;
            checkBothDone();
          }, 0);
        } else {
          timeWasmDisplay.textContent = 'Î°úÎî© Ï§ë...';
          wasmDone = true;
        }

        // ===== JavaScript Î≤ÑÏ†Ñ (ÎπÑÎèôÍ∏∞) =====
        setTimeout(() => {
          const startJs = performance.now();

          const dataJs = new Uint8ClampedArray(originalData.data);
          applyHsvJs(dataJs, hueShift, satScale, valScale);

          const imageDataJs = new ImageData(dataJs, originalData.width, originalData.height);
          ctxJs.putImageData(imageDataJs, 0, 0);

          jsTime = performance.now() - startJs;
          timeJsDisplay.textContent = `${jsTime.toFixed(2)}ms ‚úì`;

          jsDone = true;
          checkBothDone();
        }, 0);
      }
    </script>
  </body>
</html>
